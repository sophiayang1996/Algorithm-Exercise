matrix

matrix = [[0]*4 for _ in range(5)]
print(list)
[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]


heap = [y for x in matrix for y in x]


1) search matrix

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。

class Solution:
    def searchMatrix(self, matrix, target):
        '''
        从右上角开始比较，
        '''
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        if not matrix: return False
        i, j = 0, len(matrix[0]) - 1
        while(i < len(matrix) and j >= 0):
            if target == matrix[i][j]:
                return True
            elif target > matrix[i][j]:
                i += 1
            else:
                j -= 1
        return False
        
        
        
2)  第k小元素(堆排序)       
给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。

import heapq as hp
class Solution:
    
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        '''
        前k小的元素，一看就是利用堆排序，构建小根堆，第一种方法，利用python自带库heapq
        '''
        heap = [y for x in matrix for y in x]
        hp.heapify(heap)
        # print(heap)
        # print(type(heap))
        for i in range(k-1):
            hp.heappop(heap)
        return hp.heappop(heap)
